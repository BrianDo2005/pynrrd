"""test_dwi.py
================
This program is designed to test the functionality of the "dwi" submodule in
dealing with DWI meta data.

FIRST, an input test DWI scan, provided in Nrrd format, is converted to Nifti (nii.gz) using
DWIConvert tool from BRAINSTools.

SECOND, nibabel is used to read the Nifti formatted data. The data model generated by nibabel is used
to verify the compliance of the outputs of the pynrrd.

THIRD, use pynrrd (nrrd.py, dwi.py) to read the input DWI scan provided in Nrrd format.
VERIFY that the pynrrd can be converted to nibabel compliant data model

FINAL, for further validation do something interesting with manipulating DWI data
(i.e. average close gradients) and write the average Nrrd file to the disk using dwi.

Usage:
test_dwi.py --inputDWIScan DWISCAN --outputDir OUTPUTDIR --program_path PROGRAM_PATH

Options:
-h --help                        Show this help and exit
-v --version                     Print the version and exit
--inputDWIScan DWISCAN           Path to the input test DWI scan in NRRD format
--outputDir OUTPUTDIR            Path to your test directory
--program_path PROGRAM_PATH      Path to the executable of DWIConvert

"""

import os
import sys
import subprocess
from docopt import docopt
import numpy as np

from nrrd.dwi import ReadNAMICDWIFromNrrd,WriteNAMICDWIToNrrd
import nibabel as nib
from dipy.io import read_bvals_bvecs

#######################
# Auxiliary functions
#######################
def dwiconvert(nrrd_dwi_scan, output_dir, program_path):
  # Use DWIConvert (from BRAINSTools) to convert input DWI scan from Nrrd to Nifti
  output_nifti_file = os.path.join(output_dir,'testFSL.nii.gz')
  output_bvec_file = os.path.join(output_dir,'testFSL.bvec')
  output_bval_file = os.path.join(output_dir,'testFSL.bval')
  ## run DWIConvert
  # https://github.com/BRAINSia/BRAINSTools/tree/master/DWIConvert
  ##
  arg1='--inputVolume'+' '+str(nrrd_dwi_scan)
  arg2='--conversionMode NrrdToFSL'
  arg3='--outputVolume'+' '+output_nifti_file
  subprocess.call([os.path.join(program_path,'DWIConvert'), arg1, arg2, arg3])
  assert os.path.exists(output_nifti_file), "Output of DWIConvert was not found: %s" % output_nifti_file
  return output_nifti_file,output_bvec_file,output_bval_file

def unit_vector(vector):
  """ Returns the unit vector of the vector.  """
  v_norm = np.linalg.norm(vector)
  if v_norm < 1e-4: ## allow for small tolerance
    return vector
  else:
    return vector / v_norm

def angle_between(v1, v2):
  """ Returns the angle in radians between vectors 'v1' and 'v2' """
  v1_u = unit_vector(v1)
  v2_u = unit_vector(v2)
  angle = np.arccos(np.dot(v1_u, v2_u))
  if np.isnan(angle):
    if (v1_u == v2_u).all():
      return 0.0
    else:
      return np.pi
  return angle

def angle_degrees(v1,v2):
  ang_rad=angle_between(v1,v2)
  return ang_rad*180/np.pi

def average(v1,v2):
  return np.mean( np.array([ v1, v2 ]), axis=0 )

def AverageLikeGradients(nrrd_data,nrrd_bvecs,nrrd_bvals,gradient_index):
  starting_num_bvecs = len(nrrd_bvecs)
  processed_list = [ False ] * starting_num_bvecs
  remove_list = [ False ] * starting_num_bvecs
  for i in range(0,starting_num_bvecs):
    processed_list[i] = True
    for j in range(i,starting_num_bvecs):
      if processed_list[j] == False:
        if( angle_degrees(nrrd_bvecs[i], nrrd_bvecs[j] ) < 3
            and abs(nrrd_bvals[i] - nrrd_bvals[j] ) < 1 ):
               nrrd_bvecs[i] = average(nrrd_bvecs[i], nrrd_bvecs[j] )
               nrrd_bvals[i] = average(nrrd_bvals[i], nrrd_bvals[j] )
               processed_list[j] = True
               remove_list[j] = True

  # http://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html
  remove_indices = []
  for index in range(0,len(remove_list)):
    if remove_list[index]:
       remove_indices.append(index)

  nrrd_bvecs = np.delete( nrrd_bvecs, remove_indices, 0 )
  nrrd_bvals = np.delete( nrrd_bvals, remove_indices, 0 )
  if(gradient_index == -1): gradient_index = 0
  nrrd_data = np.delete( nrrd_data, remove_indices, gradient_index)
  return nrrd_data, nrrd_bvecs, nrrd_bvals

#######################
#######################
# Testing Code Here
#######################
#######################
if __name__ == '__main__':

  argv = docopt(__doc__, version='1.0')
  print argv

  DWISCAN = argv['--inputDWIScan']
  assert os.path.exists(DWISCAN), "Input DWI scan is not found: %s" % DWISCAN

  PROGRAM_PATH = argv['--program_path']

  if argv['--outputDir'] == None:
    print("Output directory is set to current working directory.")
    OUTPUTDIR = os.getcwd()
  else:
    OUTPUTDIR = argv['--outputDir']
    assert os.path.exists(OUTPUTDIR), "Output directory is not found: %s" % OUTPUTDIR

  # FIRST use DWIConvert to convert the input DWI scan from Nrrd to Nifti
  print("Making some nifti formatted data")
  [nifti_file, fbvec, fbval] = dwiconvert(DWISCAN, OUTPUTDIR, PROGRAM_PATH)

  # SECOND use nibabel to read nifti formatted DWI data
  print("Use nibabel to read nifti formatted data")

  img = nib.load(nifti_file)
  data = img.get_data()

  nifti_bvals, nifti_bvecs = read_bvals_bvecs(fbval, fbvec)
  print nifti_bvals
  print nifti_bvecs
  print type(nifti_bvals)
  print type(nifti_bvecs)

  #THIRD use nrrd.py + dwi.py to read input Nrrd DWI data
  print("Use pynrrd to read nrrd formatted data")
  nrrd_data,myOptions,nrrd_bvecs,nrrd_bvals, gradient_index = ReadNAMICDWIFromNrrd(DWISCAN)
  print type(nrrd_bvecs)
  print type(nrrd_bvals)

  # VERIFY that the pynrrd can be converted to nibabel compliant data model
  print("Verify that the pynrrd can be converted to nibabel compliant data model")
  print np.subtract(nifti_bvecs,nrrd_bvecs)
  print np.subtract(nifti_bvals,nrrd_bvals)

  # FINAL do something interesting with input DWI image
  # (i.e. use an algorithm purely in python to average similar gradients together).
  # Then, write the output to the disk.
  print("Average similar gradients of the input DWI data together")
  print("Number of components BEFORE averaging: {0}".format(len(nrrd_bvecs)))

  nrrd_data,nrrd_bvecs,nrrd_bvals=AverageLikeGradients(nrrd_data,nrrd_bvecs,nrrd_bvals,gradient_index)

  print("Number of components AFTER averaging: {0}".format(len(nrrd_bvecs)))
  #print("4th dimension of nrrd_data after averaging: {0}".format(len(nrrd_data[:,:,:,1])))

  outputNrrdFilename=os.path.join(OUTPUTDIR,'averagedNrrdFile.nrrd')
  WriteNAMICDWIToNrrd(outputNrrdFilename,nrrd_data,nrrd_bvecs,nrrd_bvals,myOptions)
  print("Output nrrd file is written to the disk: {0}.".format(outputNrrdFilename))

  sys.exit(0)
